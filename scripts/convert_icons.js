const fs = require('fs');
const path = require('path');

const svgDir = path.join(__dirname, '../assets/images');
const outputDir = path.join(__dirname, '../src/components/icons');
const outputFile = path.join(outputDir, 'AppIcons.generated.tsx');

const files = [
  { name: 'WoodIcon', file: 'WoodIcon.svg', element: 'WOOD' },
  { name: 'FireIcon', file: 'FireIcon.svg', element: 'FIRE' },
  { name: 'EarthIcon', file: 'EarthIcon.svg', element: 'EARTH' },
  { name: 'MetalIcon', file: 'MetalIcon.svg', element: 'METAL' },
  { name: 'WaterIcon', file: 'WaterIcon.svg', element: 'WATER' },
];

let generatedCode = `/**
 * AppIcons.generated.tsx
 * 
 * This file is automatically generated from the SVG assets in assets/images.
 * DO NOT EDIT MANUALLY.
 */
import React from 'react';
import { G, Path, Svg } from 'react-native-svg';
import { PHASE_CONFIG } from '../../constants/phases';
import { useThemeStore } from '../../stores/themeStore';

export interface IconProps {
  color?: string;
  size?: number;
}
`;

function convertPath(pathTag, element) {
  // Extract attributes with word boundaries to avoid matching id="path1" as d="path1"
  const dMatch = pathTag.match(/\bd="([^"]+)"/);
  const styleMatch = pathTag.match(/\bstyle="([^"]+)"/);
  const fillMatch = pathTag.match(/\bfill="([^"]+)"/);
  const transformMatch = pathTag.match(/\btransform="([^"]+)"/);
  const fillRuleMatch = pathTag.match(/\bfill-rule="([^"]+)"/);
  const strokeWidthMatch = pathTag.match(/\bstroke-width="([^"]+)"/);
  const strokeMatch = pathTag.match(/\bstroke="([^"]+)"/);

  if (!dMatch) return '';

  const attributes = [];
  attributes.push(`d="${dMatch[1]}"`);

  const style = styleMatch ? styleMatch[1] : '';
  let fill = fillMatch ? fillMatch[1] : '';
  let stroke = strokeMatch ? strokeMatch[1] : '';

  // Extract fill from style if present
  const styleFillMatch = style.match(/fill:([^;]+)/);
  if (styleFillMatch) {
    fill = styleFillMatch[1].trim();
  }

  // Extract stroke from style if present
  const styleStrokeMatch = style.match(/stroke:([^;]+)/);
  if (styleStrokeMatch) {
    stroke = styleStrokeMatch[1].trim();
  }

  // Apply color mapping
  let resolvedFill = '';
  const lowerFill = fill.toLowerCase();
  if (lowerFill === '#000000' || lowerFill === 'black') {
    resolvedFill = '{themeColors.text}';
  } else if (lowerFill === '#ffffff' || lowerFill === 'white' || lowerFill === '#ff00ff') {
    resolvedFill = `{PHASE_CONFIG.${element}.color}`;
  } else if (fill) {
    resolvedFill = `"${fill}"`;
  }

  if (resolvedFill) {
    attributes.push(`fill=${resolvedFill}`);
  }

  if (transformMatch) {
    attributes.push(`transform="${transformMatch[1]}"`);
  }

  if (fillRuleMatch) {
    const rule = fillRuleMatch[1] === 'evenodd' ? 'evenodd' : 'nonzero';
    attributes.push(`fillRule="${rule}"`);
  }

  // Handle stroke
  let resolvedStroke = '';
  const lowerStroke = stroke.toLowerCase();
  if (lowerStroke === '#000000' || lowerStroke === 'black') {
    resolvedStroke = '{themeColors.text}';
  } else if (lowerStroke === '#ffffff' || lowerStroke === 'white' || lowerStroke === '#ff00ff') {
    resolvedStroke = `{PHASE_CONFIG.${element}.color}`;
  } else if (stroke) {
    resolvedStroke = `"${stroke}"`;
  }

  if (resolvedStroke) {
    attributes.push(`stroke=${resolvedStroke}`);
  }

  let sWidth = null;
  if (strokeWidthMatch) {
    sWidth = strokeWidthMatch[1];
  } else {
    const styleSWidthMatch = style.match(/stroke-width:([^;]+)/);
    if (styleSWidthMatch) {
      sWidth = styleSWidthMatch[1];
    }
  }

  if (sWidth) {
    attributes.push(`strokeWidth="${sWidth}"`);
  }

  return `<Path ${attributes.join(' ')} />`;
}

files.forEach(icon => {
  const filePath = path.join(svgDir, icon.file);
  const content = fs.readFileSync(filePath, 'utf8');

  // Basic SVG parsing (regex based for simplicity)
  const viewBoxMatch = content.match(/viewBox="([^"]+)"/);
  const paths = [];
  // Match path tags, handling potential self-closing or multi-line
  const pathRegex = /<path([^>]+?)\/?>/gs;
  let match;
  while ((match = pathRegex.exec(content)) !== null) {
    const converted = convertPath(match[0], icon.element);
    if (converted) paths.push(converted);
  }

  generatedCode += `
export const ${icon.name}: React.FC<IconProps> = ({ size = 32 }) => {
  const themeColors = useThemeStore((state) => state.colors);
  return (
    <Svg width={size} height={size} viewBox="${
      viewBoxMatch ? viewBoxMatch[1] : '0 0 8.466 8.466'
    }" fill="none">
      <G>
        ${paths.join('\n        ')}
      </G>
    </Svg>
  );
};
`;
});

fs.writeFileSync(outputFile, generatedCode);
console.log('Successfully generated AppIcons.generated.tsx');
